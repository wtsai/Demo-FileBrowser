/*!
 * DirReader.js
 *
 * Recursive read the file directory.
 * MIT Licensed
 */

var fs = require( 'fs' );
var Path = require( 'path' );

/**
 * Read the file / directory.
 * @param {String} dir          Relative/absolute
 * @param {Function} next       function( err, path, stats, ifDir )
 * @param {Function} onFinish   Called when the whole directory is finished reading.
 */
var ReadDir = module.exports.ReadDir = function ReadDir( dir, next, onFinish ){

    dir = Path.resolve( dir );
	console.log( '[ReadDir]dir:' );
	console.log( dir );

    fs.stat( dir, function ( err, stats ){

        if( err ){
            next( err, dir );
            return;
        }

        if( stats.isDirectory() ){
            //next( undefined, dir, stats, true );
            _ReadDir( dir, next, onFinish );
        }
        else {
            throw new Error( dir + ' is not a directory' );
        }
    });
};

/**
 * This function does the real thing: reading dir.
 * @param {String} dir          Relative/absolute
 * @param {Function} next       function( err, path, stats, ifDir )
 * @param {Function} onFinish   Called when the whole directory is finished reading.
 */
function _ReadDir( dir, next, onFinish ){

    dir = Path.resolve( dir );
	//console.log( '[_ReadDir]dir:' );
	//console.log( dir );
    // Save arguments for recursive usage.
    var _arguments = arguments;
	//console.log( '[_ReadDir]_arguments:' );
	//console.log( _arguments );
	//console.log( _arguments[1] );
	//console.log( _arguments[2] );
    // These two variable is for counting the finished directory children.
    var pathLength = 0;
    var pathCount = 0;

    fs.stat( dir, function ( err, stats ){

        if( err ){
            next( err, dir );
            return;
        }

        if( stats.isDirectory() ){

            fs.readdir( dir, function ( err, pathArr ){

                if( err ){
                    next( err, dir );
                }
                else {

                    pathLength = pathArr.length;
					//console.log( '[_ReadDir]pathArr:' );
					//console.log( '[_ReadDir]pathLength:' + pathLength );
					//console.log( pathArr );
                    pathArr.forEach( function ( path ){

                        var subPath = Path.resolve( dir, path );
						//console.log( pathCount + ': [_ReadDir]dir:' + dir);
						//console.log( pathCount + ': [_ReadDir]path:' + path);
						//console.log( pathCount + ': [_ReadDir]subPath:' + subPath);

                        fs.stat( subPath, function ( err, stats ){

                            if( err ){
                                next( err, path );
                            }
                            else {
                                var ifDir = false;
                                if( stats.isDirectory() ){
                                    ifDir = true;
									//console.log( '[_ReadDir-isDirectory]pathCount: ' + pathCount );
                                    //_arguments.callee( subPath, next, function(){

                                        pathCount++;
                                        //if( pathCount === pathLength && typeof onFinish === 'function' ){
                                        //    onFinish();
                                        //}
                                    //});
                                }
                                else {
                                    // Every path not a directory is treated as 'finished reading'.
									//console.log( '[_ReadDir-isFile]pathCount: ' + pathCount );
                                    pathCount++;
                                }

								//console.log( '[_ReadDir-outer]pathCount: ' + pathCount );
                                next( undefined, path, stats, ifDir );
                                if( pathCount === pathLength && typeof onFinish === 'function' ){
                                    onFinish();
                                }
                            }
                        });
                    });
                }
            });
        }
        else {
            throw new Error( dir + ' is not a directory' );
        }
    } );
}

/**
 * Recursive read the file directory.
 * @param {String} dir          Relative/absolute
 * @param {Function} next       function( err, path, stats, ifDir )
 * @param {Function} onFinish   Called when the whole directory is finished reading.
 */
var RetrieveDir = module.exports.RetrieveDir = function RetrieveDir( dir, next, onFinish ){

    // Convert to absolute path. //Bug: Can't accept empty folder.
    dir = Path.resolve( dir );
	//console.log( 'dir:' );
	//console.log( dir );

    fs.stat( dir, function ( err, stats ){

        if( err ){
            next( err, dir );
            return;
        }

        if( stats.isDirectory() ){
            next( undefined, dir, stats, true );
            _RetrieveDir( dir, next, onFinish );
        }
        else {
            throw new Error( dir + ' is not a directory' );
        }
    });
};

/**
 * This function does the real thing: Recursive reading.
 * @param {String} dir          Relative/absolute
 * @param {Function} next       function( err, path, stats, ifDir )
 * @param {Function} onFinish   Called when the whole directory is finished reading.
 */
function _RetrieveDir( dir, next, onFinish ){

    dir = Path.resolve( dir );
    // Save arguments for recursive usage.
    var _arguments = arguments;
    // These two variable is for counting the finished directory children.
    var pathLength = 0;
    var pathCount = 0;

    fs.stat( dir, function ( err, stats ){

        if( err ){
            next( err, dir );
            return;
        }

        if( stats.isDirectory() ){

            fs.readdir( dir, function ( err, pathArr ){

                if( err ){
                    next( err, dir );
                }
                else {

                    pathLength = pathArr.length;
                    pathArr.forEach( function ( path ){

                        var subPath = Path.resolve( dir, path );

                        fs.stat( subPath, function ( err, stats ){

                            if( err ){
                                next( err, subPath );
                            }
                            else {
                                var ifDir = false;
                                if( stats.isDirectory() ){
                                    ifDir = true;
                                    _arguments.callee( subPath, next, function(){

                                        pathCount++;
                                        if( pathCount === pathLength && typeof onFinish === 'function' ){
                                            onFinish();
                                        }
                                    });
                                }
                                else {
                                    // Every path not a directory is treated as 'finished reading'.
                                    pathCount++;
                                }

                                next( undefined, subPath, stats, ifDir );
                                if( pathCount === pathLength && typeof onFinish === 'function' ){
                                    onFinish();
                                }
                            }
                        });
                    });
                }
            });
        }
        else {
            throw new Error( dir + ' is not a directory' );
        }
    } );
}

/**
 * Synchronize version of RetrieveDir.
 * Note that the `onFinish` is for nothing but make a unified interface with `RetrieveDir`.
 *
 * @param dir
 * @param next
 */
var RetrieveDirSync = module.exports.RetrieveDirSync = function( dir, next, onFinish ){

    // Convert to absolute path. //Pros: Can accept empty folder.
    dir = Path.resolve( dir );

    try{
        var stats = fs.statSync( dir );
    }
    catch( err ){
        return next( err, dir );
    }

    if( stats && stats.isDirectory() ){

        _RetrieveDirSync( dir, next );
        // Useless, just to make a unified interface.
        if( typeof onFinish === 'function' ){
            onFinish();
        }
    }
    else {
        throw new Error( dir + ' is not a directory' );
    }
};

/**
 * Synchronize version of _RetrieveDirSync.
 *
 * @param dir
 * @param next
 * @private
 */
var _RetrieveDirSync = function( dir, next ){

    // Convert to absolute path.
    dir = Path.resolve( dir );

    var _arguments = arguments;

    try{
        var stats = fs.statSync( dir );
    }
    catch( err ){
        return next( err, dir );
    }

    if( stats.isDirectory() ){

        // Trigger directory info.
        next( undefined, dir, stats, true );

        // Read directory.
        try{
            var pathArr = fs.readdirSync( dir );
        }
        catch( err ){
            return next( err, dir );
        }

        pathArr.forEach( function ( path ){

            var subPath = Path.resolve( dir, path );

            try{
                var stats = fs.statSync( subPath );
            }
            catch( err ){
                return next( err, subPath );
            }

            // If it's a directory, than recursive read it.
            if( stats.isDirectory() ){

                _arguments.callee( subPath, next );
            }
            else {
                next( undefined, subPath, stats, false );
            }

        });
    }
    else {
        throw new Error( dir + ' is not a directory' );
    }
};



